{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>torah-dl</code> - tools for downloading media from Torah websites.","text":""},{"location":"#why-torah-dl","title":"Why <code>torah-dl</code>?","text":"<p>Most of our generation's Torah content is locked up in websites that are not easily accessible. Sofer.Ai is building a platform to make Torah accessible to everyone, and we decided to build key parts of that platform in the open. We intend to support every website with Torah audio on our platform, and realized quickly that even finding all the sites with audio would be a full-time job. So we open-sourced <code>torah-dl</code> to make it easier for others to download Torah audio from any website, and make Torah more accessible!</p>"},{"location":"#how-does-it-work","title":"How does it work?","text":"<p><code>torah-dl</code> is a library and a set of command-line tools for downloading media from Torah websites. You can use it as a command-line tool with <code>uv</code> (preferred), <code>pipx</code>, <code>pip</code>, <code>poetry</code>, <code>venv</code>, or any Python tool installer of your choice, simply by running <code>uv tool install \"torah-dl[cli]\"</code>, and then running <code>torah-dl</code>.</p> <p>For those who want to integrate <code>torah-dl</code> into their Python application, you can simply install it via <code>uv add torah-dl</code> or <code>pip install torah-dl</code>. You can then use the library in your code as you would any other Python library:</p> <pre><code>from torah_dl import extract\n\nextraction = extract(\"https://www.yutorah.org/lectures/details?shiurid=1117416\")\n\nprint(extraction.download_url) # https://download.yutorah.org/2024/34263/1117416/ketuvot-57a-b---preparation-for-nisuin.mp3\n\nprint(extraction.title) # Ketuvot 57a-b - Preparation for Nisuin\n\nprint(extraction.file_format) # audio/mp3\n\nprint(extraction.file_name) # ketuvot-57a-b---preparation-for-nisuin.mp3\n</code></pre>"},{"location":"#what-sites-does-it-support","title":"What sites does it support?","text":"<p>Here is the list of sites that <code>torah-dl</code> supports already, and what's coming soon:</p> <ul> <li> Yutorah</li> <li> TorahAnytime</li> <li> TorahApp</li> <li> OUTorah.org</li> <li> AllDaf.org</li> <li> AllHalacha.org</li> <li> AllParsha.com</li> <li> AllMishna.com</li> <li> TorahDownloads.org</li> <li> Help us out by adding your favorite Torah website!</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We'd love your help! Please see our CONTRIBUTING.md for more information on how to get involved.</p>"},{"location":"#frequently-asked-questions","title":"Frequently Asked Questions","text":"Am I allowed to download Torah audio from these websites?  ### You are responsible for ensuring that you follow all Terms of Service agreements, Copyright agreements, and other legal agreements with these websites.  TODO: get a lawyer to review this.  How do I download audio from a site that is not on the list?  ### We'd love your help! Please see our [CONTRIBUTING.md](CONTRIBUTING.md) for more information on how to get involved.  What are the usecases for `torah-dl`?  Allowing transcription services to make Torah more accessible \ud83d\ude09  Other uses include downloading Torah audio for offline listening, or for use in Torah study tools, or for training AI models to understand Torah, or for other purposes (please see question above about permissions)."},{"location":"#contributors","title":"Contributors","text":""},{"location":"CONTRIBUTING/","title":"Contributing to <code>torah-dl</code>","text":""},{"location":"CONTRIBUTING/#how-to-contribute","title":"How to contribute","text":"<ol> <li>Fork the repository</li> <li>Create a new branch for your changes</li> <li>Make your changes and commit them</li> <li>Open a pull request</li> </ol>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>We follow the Contributor Covenant code of conduct. Additionally, we expect everyone contributing to behave Al Kiddush Hashem and not engage in any behavior that could be considered inappropriate or offensive.</p>"},{"location":"CONTRIBUTING/#how-to-run-the-project","title":"How to run the project","text":"<p>We use Hermit to manage our development environment. To get started, install Hermit with:</p> <pre><code>curl -fsSL https://github.com/cashapp/hermit/releases/download/stable/install.sh | /bin/bash\n</code></pre> <p>Hermit will automatically install and manage <code>uv</code> and <code>task</code> for you when you run any of the project commands.</p> <p>Once Hermit is installed, you can install the project's dependencies by running <code>uv sync</code>.</p> <p>To run the project, use <code>uv run pytest -vv -s --cov=torah_dl</code> to run the tests, or <code>task test</code> if you have task installed.</p> <p>This is foundational software, and we maintain a very high standard for code quality. Please make sure your code passes <code>ruff check --fix</code> before submitting a pull request. While code coverage is a poor metric for judging the quality of this project, we strive to maintain the existing 90%+ coverage. Additionally, our tests actually download and extract the metadata from the target sites, which means we are constantly ensuring that our tooling works as intended. Please help us maintain that level of service with your tests.</p>"},{"location":"MANUAL/","title":"<code>torah-dl</code>","text":"<p>SoferAI's Torah Downloader</p> <p>Usage:</p> <pre><code>$ torah-dl [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--version</code></li> <li><code>--install-completion</code>: Install completion for the current shell.</li> <li><code>--show-completion</code>: Show completion for the current shell, to copy it or customize the installation.</li> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>extract</code>: Extract information from a given URL</li> <li><code>download</code>: Download a file from a URL and show progress.</li> </ul>"},{"location":"MANUAL/#torah-dl-extract","title":"<code>torah-dl extract</code>","text":"<p>Extract information from a given URL</p> <p>Usage:</p> <pre><code>$ torah-dl extract [OPTIONS] URL\n</code></pre> <p>Arguments:</p> <ul> <li><code>URL</code>: [required]</li> </ul> <p>Options:</p> <ul> <li><code>--url-only</code>: Only output the download URL</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"MANUAL/#torah-dl-download","title":"<code>torah-dl download</code>","text":"<p>Download a file from a URL and show progress.</p> <p>Usage:</p> <pre><code>$ torah-dl download [OPTIONS] URL [OUTPUT_PATH]\n</code></pre> <p>Arguments:</p> <ul> <li><code>URL</code>: URL to download  [required]</li> <li><code>[OUTPUT_PATH]</code>: Path to save the downloaded file  [default: audio]</li> </ul> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>torah_dl<ul> <li>cli</li> <li>core<ul> <li>download</li> <li>exceptions</li> <li>extract</li> <li>extractors<ul> <li>alldaf</li> <li>outorah</li> <li>torahanytime</li> <li>torahapp</li> <li>torahdownloads</li> <li>yutorah</li> </ul> </li> <li>models</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/torah_dl/","title":"torah_dl","text":""},{"location":"reference/torah_dl/#torah_dl.ContentExtractionError","title":"ContentExtractionError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when required content cannot be extracted from the page.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class ContentExtractionError(ExtractionError):\n    \"\"\"Raised when required content cannot be extracted from the page.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.DownloadError","title":"DownloadError","text":"<p>               Bases: <code>TorahDLError</code></p> <p>Raised when there are issues during the download process.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class DownloadError(TorahDLError):\n    \"\"\"Raised when there are issues during the download process.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.DownloadURLError","title":"DownloadURLError","text":"<p>               Bases: <code>ContentExtractionError</code></p> <p>Raised when the download URL cannot be found or extracted.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class DownloadURLError(ContentExtractionError):\n    \"\"\"Raised when the download URL cannot be found or extracted.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.Extraction","title":"Extraction","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the extracted data from a source.</p> Source code in <code>src/torah_dl/core/models.py</code> <pre><code>class Extraction(BaseModel):\n    \"\"\"Represents the extracted data from a source.\"\"\"\n\n    title: str | None = None\n    download_url: str\n    file_format: str | None = None\n    file_name: str | None = None\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>TorahDLError</code></p> <p>Base class for all extraction-related errors.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class ExtractionError(TorahDLError):\n    \"\"\"Base class for all extraction-related errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.ExtractorNotFoundError","title":"ExtractorNotFoundError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when no extractor is found for a given URL.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class ExtractorNotFoundError(ExtractionError):\n    \"\"\"Raised when no extractor is found for a given URL.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.NetworkError","title":"NetworkError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when there are network-related issues during content extraction.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class NetworkError(ExtractionError):\n    \"\"\"Raised when there are network-related issues during content extraction.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.TitleExtractionError","title":"TitleExtractionError","text":"<p>               Bases: <code>ContentExtractionError</code></p> <p>Raised when the title cannot be found or decoded.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class TitleExtractionError(ContentExtractionError):\n    \"\"\"Raised when the title cannot be found or decoded.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.TorahDLError","title":"TorahDLError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class for all torah-dl errors.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class TorahDLError(Exception):\n    \"\"\"Base exception class for all torah-dl errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.can_handle","title":"can_handle","text":"<pre><code>can_handle(url: str) -&gt; bool\n</code></pre> <p>Checks if a given URL can be handled by any extractor.</p> Source code in <code>src/torah_dl/core/extract.py</code> <pre><code>def can_handle(url: str) -&gt; bool:\n    \"\"\"Checks if a given URL can be handled by any extractor.\"\"\"\n    return any(extractor.can_handle(url) for extractor in EXTRACTORS)\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.download","title":"download","text":"<pre><code>download(url: str, output_path: Path, timeout: int = 30)\n</code></pre> <p>Download a file from a given URL and save it to the specified output path.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to download from</p> required <code>output_path</code> <code>Path</code> <p>The path to save the downloaded file to</p> required <code>timeout</code> <code>int</code> <p>The timeout for the request</p> <code>30</code> Source code in <code>src/torah_dl/core/download.py</code> <pre><code>def download(url: str, output_path: Path, timeout: int = 30):\n    \"\"\"Download a file from a given URL and save it to the specified output path.\n\n    Args:\n        url: The URL to download from\n        output_path: The path to save the downloaded file to\n        timeout: The timeout for the request\n    \"\"\"\n    try:\n        response = requests.get(url, timeout=timeout)\n        response.raise_for_status()\n\n    except requests.RequestException as e:\n        raise DownloadError(url) from e\n\n    with open(output_path, \"wb\") as f:\n        f.write(response.content)\n</code></pre>"},{"location":"reference/torah_dl/#torah_dl.extract","title":"extract","text":"<pre><code>extract(url: str) -&gt; Extraction\n</code></pre> <p>Extracts the download URL, title, and file format from a given URL.</p> Source code in <code>src/torah_dl/core/extract.py</code> <pre><code>def extract(url: str) -&gt; Extraction:\n    \"\"\"Extracts the download URL, title, and file format from a given URL.\"\"\"\n    for extractor in EXTRACTORS:\n        if extractor.can_handle(url):\n            return extractor.extract(url)\n\n    raise ExtractorNotFoundError(url)\n</code></pre>"},{"location":"reference/torah_dl/cli/","title":"cli","text":""},{"location":"reference/torah_dl/cli/#torah_dl.cli.callback","title":"callback","text":"<pre><code>callback(\n    version: Annotated[\n        bool | None,\n        typer.Option(\n            --version,\n            callback=version_callback,\n            is_eager=True,\n        ),\n    ] = None,\n)\n</code></pre> <p>SoferAI's Torah Downloader</p> Source code in <code>src/torah_dl/cli.py</code> <pre><code>@app.callback(invoke_without_command=True)\ndef callback(\n    version: Annotated[\n        bool | None,\n        typer.Option(\"--version\", callback=version_callback, is_eager=True),\n    ] = None,\n):\n    \"\"\"\n    SoferAI's Torah Downloader\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/torah_dl/cli/#torah_dl.cli.download_url","title":"download_url","text":"<pre><code>download_url(\n    url: Annotated[\n        str, typer.Argument(help=\"URL to download\")\n    ],\n    output_path: Annotated[\n        Path,\n        typer.Argument(\n            help=\"Path to save the downloaded file\"\n        ),\n    ] = Path(\"audio\"),\n)\n</code></pre> <p>Download a file from a URL and show progress.</p> Source code in <code>src/torah_dl/cli.py</code> <pre><code>@app.command(name=\"download\")\ndef download_url(\n    url: Annotated[str, typer.Argument(help=\"URL to download\")],\n    output_path: Annotated[Path, typer.Argument(help=\"Path to save the downloaded file\")] = Path(\"audio\"),\n):\n    \"\"\"Download a file from a URL and show progress.\"\"\"\n    with console.status(\"Extracting URL...\"):\n        extraction = extract(url)\n    with console.status(\"Downloading file...\"):\n        download(extraction.download_url, output_path)\n</code></pre>"},{"location":"reference/torah_dl/cli/#torah_dl.cli.extract_url","title":"extract_url","text":"<pre><code>extract_url(\n    url: str,\n    url_only: Annotated[\n        bool,\n        typer.Option(\n            --url - only,\n            help=\"Only output the download URL\",\n        ),\n    ] = False,\n)\n</code></pre> <p>Extract information from a given URL</p> Source code in <code>src/torah_dl/cli.py</code> <pre><code>@app.command(name=\"extract\")\ndef extract_url(\n    url: str,\n    url_only: Annotated[bool, typer.Option(\"--url-only\", help=\"Only output the download URL\")] = False,\n):\n    \"\"\"\n    Extract information from a given URL\n    \"\"\"\n    with console.status(\"Extracting URL...\"):\n        try:\n            extraction = extract(url)\n        except ExtractorNotFoundError:\n            typer.echo(f\"Extractor not found for URL: {url}\", err=True)\n            raise typer.Exit(1) from None\n\n    if url_only:\n        typer.echo(extraction.download_url)\n    else:\n        table = Table(box=None, pad_edge=False)\n        table.add_row(\"Title\", extraction.title, style=\"cyan\")\n        table.add_row(\"Download URL\", extraction.download_url, style=\"green\")\n        console.print(table)\n</code></pre>"},{"location":"reference/torah_dl/cli/#torah_dl.cli.version_callback","title":"version_callback","text":"<pre><code>version_callback(value: bool)\n</code></pre> <p>print version information to shell</p> Source code in <code>src/torah_dl/cli.py</code> <pre><code>def version_callback(value: bool):\n    \"\"\"\n    print version information to shell\n    \"\"\"\n    if value:\n        typer.echo(f\"torah-dl version: {__version__}\")\n        raise typer.Exit()\n</code></pre>"},{"location":"reference/torah_dl/core/","title":"core","text":""},{"location":"reference/torah_dl/core/download/","title":"download","text":""},{"location":"reference/torah_dl/core/download/#torah_dl.core.download.download","title":"download","text":"<pre><code>download(url: str, output_path: Path, timeout: int = 30)\n</code></pre> <p>Download a file from a given URL and save it to the specified output path.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to download from</p> required <code>output_path</code> <code>Path</code> <p>The path to save the downloaded file to</p> required <code>timeout</code> <code>int</code> <p>The timeout for the request</p> <code>30</code> Source code in <code>src/torah_dl/core/download.py</code> <pre><code>def download(url: str, output_path: Path, timeout: int = 30):\n    \"\"\"Download a file from a given URL and save it to the specified output path.\n\n    Args:\n        url: The URL to download from\n        output_path: The path to save the downloaded file to\n        timeout: The timeout for the request\n    \"\"\"\n    try:\n        response = requests.get(url, timeout=timeout)\n        response.raise_for_status()\n\n    except requests.RequestException as e:\n        raise DownloadError(url) from e\n\n    with open(output_path, \"wb\") as f:\n        f.write(response.content)\n</code></pre>"},{"location":"reference/torah_dl/core/exceptions/","title":"exceptions","text":""},{"location":"reference/torah_dl/core/exceptions/#torah_dl.core.exceptions.ContentExtractionError","title":"ContentExtractionError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when required content cannot be extracted from the page.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class ContentExtractionError(ExtractionError):\n    \"\"\"Raised when required content cannot be extracted from the page.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/core/exceptions/#torah_dl.core.exceptions.DownloadError","title":"DownloadError","text":"<p>               Bases: <code>TorahDLError</code></p> <p>Raised when there are issues during the download process.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class DownloadError(TorahDLError):\n    \"\"\"Raised when there are issues during the download process.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/core/exceptions/#torah_dl.core.exceptions.DownloadURLError","title":"DownloadURLError","text":"<p>               Bases: <code>ContentExtractionError</code></p> <p>Raised when the download URL cannot be found or extracted.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class DownloadURLError(ContentExtractionError):\n    \"\"\"Raised when the download URL cannot be found or extracted.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/core/exceptions/#torah_dl.core.exceptions.ExtractionError","title":"ExtractionError","text":"<p>               Bases: <code>TorahDLError</code></p> <p>Base class for all extraction-related errors.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class ExtractionError(TorahDLError):\n    \"\"\"Base class for all extraction-related errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/core/exceptions/#torah_dl.core.exceptions.ExtractorNotFoundError","title":"ExtractorNotFoundError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when no extractor is found for a given URL.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class ExtractorNotFoundError(ExtractionError):\n    \"\"\"Raised when no extractor is found for a given URL.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/core/exceptions/#torah_dl.core.exceptions.NetworkError","title":"NetworkError","text":"<p>               Bases: <code>ExtractionError</code></p> <p>Raised when there are network-related issues during content extraction.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class NetworkError(ExtractionError):\n    \"\"\"Raised when there are network-related issues during content extraction.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/core/exceptions/#torah_dl.core.exceptions.TitleExtractionError","title":"TitleExtractionError","text":"<p>               Bases: <code>ContentExtractionError</code></p> <p>Raised when the title cannot be found or decoded.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class TitleExtractionError(ContentExtractionError):\n    \"\"\"Raised when the title cannot be found or decoded.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/core/exceptions/#torah_dl.core.exceptions.TorahDLError","title":"TorahDLError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class for all torah-dl errors.</p> Source code in <code>src/torah_dl/core/exceptions.py</code> <pre><code>class TorahDLError(Exception):\n    \"\"\"Base exception class for all torah-dl errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/torah_dl/core/extract/","title":"extract","text":""},{"location":"reference/torah_dl/core/extract/#torah_dl.core.extract.can_handle","title":"can_handle","text":"<pre><code>can_handle(url: str) -&gt; bool\n</code></pre> <p>Checks if a given URL can be handled by any extractor.</p> Source code in <code>src/torah_dl/core/extract.py</code> <pre><code>def can_handle(url: str) -&gt; bool:\n    \"\"\"Checks if a given URL can be handled by any extractor.\"\"\"\n    return any(extractor.can_handle(url) for extractor in EXTRACTORS)\n</code></pre>"},{"location":"reference/torah_dl/core/extract/#torah_dl.core.extract.extract","title":"extract","text":"<pre><code>extract(url: str) -&gt; Extraction\n</code></pre> <p>Extracts the download URL, title, and file format from a given URL.</p> Source code in <code>src/torah_dl/core/extract.py</code> <pre><code>def extract(url: str) -&gt; Extraction:\n    \"\"\"Extracts the download URL, title, and file format from a given URL.\"\"\"\n    for extractor in EXTRACTORS:\n        if extractor.can_handle(url):\n            return extractor.extract(url)\n\n    raise ExtractorNotFoundError(url)\n</code></pre>"},{"location":"reference/torah_dl/core/models/","title":"models","text":""},{"location":"reference/torah_dl/core/models/#torah_dl.core.models.Extraction","title":"Extraction","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the extracted data from a source.</p> Source code in <code>src/torah_dl/core/models.py</code> <pre><code>class Extraction(BaseModel):\n    \"\"\"Represents the extracted data from a source.\"\"\"\n\n    title: str | None = None\n    download_url: str\n    file_format: str | None = None\n    file_name: str | None = None\n</code></pre>"},{"location":"reference/torah_dl/core/models/#torah_dl.core.models.ExtractionExample","title":"ExtractionExample","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an example of an extraction.</p> Source code in <code>src/torah_dl/core/models.py</code> <pre><code>class ExtractionExample(BaseModel):\n    \"\"\"Represents an example of an extraction.\"\"\"\n\n    name: str\n    url: str\n    download_url: str\n    title: str\n    file_format: str\n    valid: bool\n</code></pre>"},{"location":"reference/torah_dl/core/models/#torah_dl.core.models.Extractor","title":"Extractor","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all extractors.</p> Source code in <code>src/torah_dl/core/models.py</code> <pre><code>class Extractor(ABC):\n    \"\"\"Abstract base class for all extractors.\"\"\"\n\n    EXAMPLES: ClassVar[list[ExtractionExample]] = []\n\n    @property\n    @abstractmethod\n    def url_patterns(self) -&gt; Pattern | list[Pattern]:\n        \"\"\"\n        Returns the regex pattern(s) that match URLs this extractor can handle.\n        Can return either a single compiled regex pattern or a list of patterns.\n        \"\"\"\n        ...  # pragma: no cover\n\n    def can_handle(self, url: str) -&gt; bool:\n        \"\"\"\n        Checks if this extractor can handle the given URL.\n\n        Args:\n            url: The URL to check\n\n        Returns:\n            bool: True if this extractor can handle the URL, False otherwise\n        \"\"\"\n        patterns = self.url_patterns\n        if isinstance(patterns, Pattern):\n            patterns = [patterns]\n\n        return any(pattern.match(url) for pattern in patterns)\n\n    @abstractmethod\n    def extract(self, url: str) -&gt; Extraction:\n        \"\"\"\n        Extracts data from the given URL.\n\n        Args:\n            url: The URL to extract from\n\n        Returns:\n            Extraction: The extracted data\n\n        Raises:\n            ValueError: If the URL is not supported by this extractor\n        \"\"\"\n        ...  # pragma: no cover\n</code></pre>"},{"location":"reference/torah_dl/core/models/#torah_dl.core.models.Extractor.url_patterns","title":"url_patterns  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>url_patterns: Pattern | list[Pattern]\n</code></pre> <p>Returns the regex pattern(s) that match URLs this extractor can handle. Can return either a single compiled regex pattern or a list of patterns.</p>"},{"location":"reference/torah_dl/core/models/#torah_dl.core.models.Extractor.can_handle","title":"can_handle","text":"<pre><code>can_handle(url: str) -&gt; bool\n</code></pre> <p>Checks if this extractor can handle the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this extractor can handle the URL, False otherwise</p> Source code in <code>src/torah_dl/core/models.py</code> <pre><code>def can_handle(self, url: str) -&gt; bool:\n    \"\"\"\n    Checks if this extractor can handle the given URL.\n\n    Args:\n        url: The URL to check\n\n    Returns:\n        bool: True if this extractor can handle the URL, False otherwise\n    \"\"\"\n    patterns = self.url_patterns\n    if isinstance(patterns, Pattern):\n        patterns = [patterns]\n\n    return any(pattern.match(url) for pattern in patterns)\n</code></pre>"},{"location":"reference/torah_dl/core/models/#torah_dl.core.models.Extractor.extract","title":"extract  <code>abstractmethod</code>","text":"<pre><code>extract(url: str) -&gt; Extraction\n</code></pre> <p>Extracts data from the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to extract from</p> required <p>Returns:</p> Name Type Description <code>Extraction</code> <code>Extraction</code> <p>The extracted data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL is not supported by this extractor</p> Source code in <code>src/torah_dl/core/models.py</code> <pre><code>@abstractmethod\ndef extract(self, url: str) -&gt; Extraction:\n    \"\"\"\n    Extracts data from the given URL.\n\n    Args:\n        url: The URL to extract from\n\n    Returns:\n        Extraction: The extracted data\n\n    Raises:\n        ValueError: If the URL is not supported by this extractor\n    \"\"\"\n    ...  # pragma: no cover\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/","title":"extractors","text":""},{"location":"reference/torah_dl/core/extractors/alldaf/","title":"alldaf","text":""},{"location":"reference/torah_dl/core/extractors/alldaf/#torah_dl.core.extractors.alldaf.AllDafExtractor","title":"AllDafExtractor","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract audio/video content from AllDaf.org.</p> <p>This extractor handles URLs from alldaf.org and extracts MP3/MP4 download links along with their associated titles from various locations in the page.</p> Source code in <code>src/torah_dl/core/extractors/alldaf.py</code> <pre><code>class AllDafExtractor(Extractor):\n    \"\"\"Extract audio/video content from AllDaf.org.\n\n    This extractor handles URLs from alldaf.org and extracts MP3/MP4 download\n    links along with their associated titles from various locations in the page.\n    \"\"\"\n\n    EXAMPLES = [  # noqa: RUF012\n        ExtractionExample(\n            name=\"main_page\",\n            url=\"https://alldaf.org/p/36785\",\n            download_url=\"https://media.ou.org/torah/2925/36785/36785.mp3\",\n            title=\"Sanhedrin 40\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"another_page\",\n            url=\"https://alldaf.org/p/215503\",\n            download_url=\"https://media.ou.org/torah/4049/215503/215503.mp3\",\n            title=\"Sanhedrin 40 - Cycle 14\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"invalid_link\",\n            url=\"https://alldaf.org/p/000000\",\n            download_url=\"\",\n            title=\"\",\n            file_format=\"\",\n            valid=False,\n        ),\n    ]\n\n    # URL pattern for AllDaf.org pages\n    URL_PATTERN = re.compile(r\"https?://(?:www\\.)?alldaf\\.org/\")\n\n    # Patterns to find download URLs in various locations\n    ACTION_BAR_URL_PATTERN = re.compile(r\"s3Url=(.*?\\.mp[34])\")\n    ACTION_BAR_TITLE_PATTERN = re.compile(r\"title=(.*?)&amp;\")\n    SCRIPT_URL_PATTERN = re.compile(\n        r\"(?:audioUrl|audio_url|url|videoUrl)\\s*:\\s*['\\\"]([^'\\\"]+\\.mp[34])['\\\"]\", flags=re.IGNORECASE\n    )\n    RAW_URL_PATTERN = re.compile(r\"https?://[^\\\"'\\s]+\\.mp[34]\")\n\n    @property\n    def url_patterns(self) -&gt; list[Pattern]:\n        \"\"\"Return the URL pattern(s) that this extractor can handle.\n\n        Returns:\n            List[Pattern]: List of compiled regex patterns matching AllDaf.org URLs\n        \"\"\"\n        return [self.URL_PATTERN]\n\n    def extract(self, url: str) -&gt; Extraction:\n        \"\"\"Extract download URL and title from an AllDaf.org page.\n\n        Args:\n            url: The AllDaf.org URL to extract from\n\n        Returns:\n            Extraction: Object containing the download URL and title\n\n        Raises:\n            ValueError: If the URL is invalid or content cannot be extracted\n            requests.RequestException: If there are network-related issues\n        \"\"\"\n        try:\n            response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n            response.raise_for_status()\n        except requests.RequestException as e:\n            raise NetworkError(str(e)) from e  # pragma: no cover\n\n        # Parse the page content\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        # html = str(response.content)\n\n        # Try finding download link in the action bar first\n        action_bar_link = soup.select_one('.publication-action-bar__item[href*=\"s3Url=\"]')\n        if action_bar_link:\n            href = action_bar_link.get(\"href\", \"\")\n            s3_url_match = self.ACTION_BAR_URL_PATTERN.search(href)\n            title_match = self.ACTION_BAR_TITLE_PATTERN.search(href)\n\n            if s3_url_match:\n                download_url = requests.utils.unquote(s3_url_match.group(1))\n                title = requests.utils.unquote(title_match.group(1)) if title_match else None\n                file_format = f\"audio/{download_url.split('.')[-1].lower()}\"\n                file_name = download_url.split(\"/\")[-1]\n                return Extraction(download_url=download_url, title=title, file_format=file_format, file_name=file_name)\n\n        # # Try finding audio/video elements as fallback\n        # media_selector = (\n        #     'audio source[src*=\".mp3\"], audio[src*=\".mp3\"], a[href*=\".mp3\"],'\n        #     'video source[src*=\".mp4\"], video[src*=\".mp4\"], .jw-video[src*=\".mp4\"]'\n        # )\n        # media_element = soup.select_one(media_selector)\n        # if media_element:\n        #     src = media_element.get(\"src\") or media_element.get(\"href\")\n        #     if src:\n        #         title = soup.select_one(\"h1\")\n        #         title = title.get_text().strip() if title else None\n        #         file_format = f\"audio/{src.split('.')[-1].lower()}\"\n        #         file_name = src.split(\"/\")[-1]\n        #         return Extraction(download_url=src, title=title, file_format=file_format, file_name=file_name)\n\n        # Try finding audio/video URL in script tags\n        # for script in soup.find_all(\"script\"):\n        #     content = script.string or \"\"\n        #     media_url_match = self.SCRIPT_URL_PATTERN.search(content)\n        #     if media_url_match:\n        #         download_url = media_url_match.group(1)\n        #         title = soup.select_one(\"h1\")\n        #         title = title.get_text().strip() if title else None\n        #         file_format = f\"audio/{download_url.split('.')[-1].lower()}\"\n        #         file_name = download_url.split(\"/\")[-1]\n        #        return Extraction(download_url=download_url, title=title, file_format=file_format, file_name=file_name)\n\n        # Try finding in the raw HTML for any mp3/mp4 URLs\n        # media_url_match = self.RAW_URL_PATTERN.search(html)\n        # if media_url_match:\n        #     download_url = media_url_match.group(0)\n        #     title = soup.select_one(\"h1\")\n        #     title = title.get_text().strip() if title else None\n        #     file_format = f\"audio/{download_url.split('.')[-1].lower()}\"\n        #     file_name = download_url.split(\"/\")[-1]\n        #     return Extraction(download_url=download_url, title=title, file_format=file_format, file_name=file_name)\n\n        raise DownloadURLError()\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/alldaf/#torah_dl.core.extractors.alldaf.AllDafExtractor.url_patterns","title":"url_patterns  <code>property</code>","text":"<pre><code>url_patterns: list[Pattern]\n</code></pre> <p>Return the URL pattern(s) that this extractor can handle.</p> <p>Returns:</p> Type Description <code>list[Pattern]</code> <p>List[Pattern]: List of compiled regex patterns matching AllDaf.org URLs</p>"},{"location":"reference/torah_dl/core/extractors/alldaf/#torah_dl.core.extractors.alldaf.AllDafExtractor.extract","title":"extract","text":"<pre><code>extract(url: str) -&gt; Extraction\n</code></pre> <p>Extract download URL and title from an AllDaf.org page.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The AllDaf.org URL to extract from</p> required <p>Returns:</p> Name Type Description <code>Extraction</code> <code>Extraction</code> <p>Object containing the download URL and title</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL is invalid or content cannot be extracted</p> <code>RequestException</code> <p>If there are network-related issues</p> Source code in <code>src/torah_dl/core/extractors/alldaf.py</code> <pre><code>def extract(self, url: str) -&gt; Extraction:\n    \"\"\"Extract download URL and title from an AllDaf.org page.\n\n    Args:\n        url: The AllDaf.org URL to extract from\n\n    Returns:\n        Extraction: Object containing the download URL and title\n\n    Raises:\n        ValueError: If the URL is invalid or content cannot be extracted\n        requests.RequestException: If there are network-related issues\n    \"\"\"\n    try:\n        response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n        response.raise_for_status()\n    except requests.RequestException as e:\n        raise NetworkError(str(e)) from e  # pragma: no cover\n\n    # Parse the page content\n    soup = BeautifulSoup(response.content, \"html.parser\")\n    # html = str(response.content)\n\n    # Try finding download link in the action bar first\n    action_bar_link = soup.select_one('.publication-action-bar__item[href*=\"s3Url=\"]')\n    if action_bar_link:\n        href = action_bar_link.get(\"href\", \"\")\n        s3_url_match = self.ACTION_BAR_URL_PATTERN.search(href)\n        title_match = self.ACTION_BAR_TITLE_PATTERN.search(href)\n\n        if s3_url_match:\n            download_url = requests.utils.unquote(s3_url_match.group(1))\n            title = requests.utils.unquote(title_match.group(1)) if title_match else None\n            file_format = f\"audio/{download_url.split('.')[-1].lower()}\"\n            file_name = download_url.split(\"/\")[-1]\n            return Extraction(download_url=download_url, title=title, file_format=file_format, file_name=file_name)\n\n    # # Try finding audio/video elements as fallback\n    # media_selector = (\n    #     'audio source[src*=\".mp3\"], audio[src*=\".mp3\"], a[href*=\".mp3\"],'\n    #     'video source[src*=\".mp4\"], video[src*=\".mp4\"], .jw-video[src*=\".mp4\"]'\n    # )\n    # media_element = soup.select_one(media_selector)\n    # if media_element:\n    #     src = media_element.get(\"src\") or media_element.get(\"href\")\n    #     if src:\n    #         title = soup.select_one(\"h1\")\n    #         title = title.get_text().strip() if title else None\n    #         file_format = f\"audio/{src.split('.')[-1].lower()}\"\n    #         file_name = src.split(\"/\")[-1]\n    #         return Extraction(download_url=src, title=title, file_format=file_format, file_name=file_name)\n\n    # Try finding audio/video URL in script tags\n    # for script in soup.find_all(\"script\"):\n    #     content = script.string or \"\"\n    #     media_url_match = self.SCRIPT_URL_PATTERN.search(content)\n    #     if media_url_match:\n    #         download_url = media_url_match.group(1)\n    #         title = soup.select_one(\"h1\")\n    #         title = title.get_text().strip() if title else None\n    #         file_format = f\"audio/{download_url.split('.')[-1].lower()}\"\n    #         file_name = download_url.split(\"/\")[-1]\n    #        return Extraction(download_url=download_url, title=title, file_format=file_format, file_name=file_name)\n\n    # Try finding in the raw HTML for any mp3/mp4 URLs\n    # media_url_match = self.RAW_URL_PATTERN.search(html)\n    # if media_url_match:\n    #     download_url = media_url_match.group(0)\n    #     title = soup.select_one(\"h1\")\n    #     title = title.get_text().strip() if title else None\n    #     file_format = f\"audio/{download_url.split('.')[-1].lower()}\"\n    #     file_name = download_url.split(\"/\")[-1]\n    #     return Extraction(download_url=download_url, title=title, file_format=file_format, file_name=file_name)\n\n    raise DownloadURLError()\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/outorah/","title":"outorah","text":""},{"location":"reference/torah_dl/core/extractors/outorah/#torah_dl.core.extractors.outorah.OutorahExtractor","title":"OutorahExtractor","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract audio content from Outorah.org.</p> <p>This extractor handles URLs from www.outorah.org and extracts MP3 download links along with their associated titles from the page's JavaScript content.</p> Source code in <code>src/torah_dl/core/extractors/outorah.py</code> <pre><code>class OutorahExtractor(Extractor):\n    \"\"\"Extract audio content from Outorah.org.\n\n    This extractor handles URLs from www.outorah.org and extracts MP3 download\n    links along with their associated titles from the page's JavaScript content.\n    \"\"\"\n\n    EXAMPLES = [  # noqa: RUF012\n        ExtractionExample(\n            name=\"main_page\",\n            url=\"https://outorah.org/p/212365\",\n            download_url=\"https://media.ou.org/torah/4093/212365/212365.mp3\",\n            title=\"Parshat Miketz: A Chanukah Charade\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"invalid_link\",\n            url=\"https://outorah.org/p/0000000\",\n            download_url=\"\",\n            title=\"\",\n            file_format=\"\",\n            valid=False,\n        ),\n    ]\n\n    # URL pattern for Outorah.org pages\n    URL_PATTERN = re.compile(r\"https?://(?:www\\.)?outorah\\.org/\")\n\n    # Pattern to find download URL in script tags\n    MP3_DOWNLOAD_URL_PATTERN = re.compile(r\"s3Url=.*\\.mp3\")\n    MP4_DOWNLOAD_URL_PATTERN = re.compile(r\"s3Url=.*\\.mp4\")\n\n    @property\n    def url_patterns(self) -&gt; list[Pattern]:\n        \"\"\"Return the URL pattern(s) that this extractor can handle.\n\n        Returns:\n            List[Pattern]: List of compiled regex patterns matching Outorah.org URLs\n        \"\"\"\n        return [self.URL_PATTERN]\n\n    def extract(self, url: str) -&gt; Extraction:\n        \"\"\"Extract download URL and title from a Outorah.org page.\n\n        Args:\n            url: The Outorah.org URL to extract from\n\n        Returns:\n            Extraction: Object containing the download URL and title\n\n        Raises:\n            ValueError: If the URL is invalid or content cannot be extracted\n            requests.RequestException: If there are network-related issues\n        \"\"\"\n        try:\n            response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n            response.raise_for_status()\n        except requests.RequestException as e:\n            raise NetworkError(str(e)) from e  # pragma: no cover\n\n        # Parse the page content\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        if download_link := soup.find(\"a\", attrs={\"href\": self.MP3_DOWNLOAD_URL_PATTERN}):\n            download_url = re.search(r\"s3Url=(.*\\.mp3)\", download_link[\"href\"]).group(1)\n            title = re.search(r\"title=(.*?)&amp;\", download_link[\"href\"])\n            if title:\n                title = urllib.parse.unquote(title.group(1))\n        elif download_link := soup.find(\"a\", attrs={\"href\": self.MP4_DOWNLOAD_URL_PATTERN}):\n            download_url = re.search(r\"s3Url=(.*\\.mp4)\", download_link[\"href\"]).group(1)\n            title = re.search(r\"title=(.*?)&amp;\", download_link[\"href\"])\n            if title:\n                title = urllib.parse.unquote(title.group(1))\n        else:\n            raise DownloadURLError()\n\n        file_name = download_url.split(\"/\")[-1]\n\n        if not download_url or not title:\n            raise ContentExtractionError()\n\n        return Extraction(download_url=download_url, title=title, file_format=\"audio/mp3\", file_name=file_name)\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/outorah/#torah_dl.core.extractors.outorah.OutorahExtractor.url_patterns","title":"url_patterns  <code>property</code>","text":"<pre><code>url_patterns: list[Pattern]\n</code></pre> <p>Return the URL pattern(s) that this extractor can handle.</p> <p>Returns:</p> Type Description <code>list[Pattern]</code> <p>List[Pattern]: List of compiled regex patterns matching Outorah.org URLs</p>"},{"location":"reference/torah_dl/core/extractors/outorah/#torah_dl.core.extractors.outorah.OutorahExtractor.extract","title":"extract","text":"<pre><code>extract(url: str) -&gt; Extraction\n</code></pre> <p>Extract download URL and title from a Outorah.org page.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The Outorah.org URL to extract from</p> required <p>Returns:</p> Name Type Description <code>Extraction</code> <code>Extraction</code> <p>Object containing the download URL and title</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL is invalid or content cannot be extracted</p> <code>RequestException</code> <p>If there are network-related issues</p> Source code in <code>src/torah_dl/core/extractors/outorah.py</code> <pre><code>def extract(self, url: str) -&gt; Extraction:\n    \"\"\"Extract download URL and title from a Outorah.org page.\n\n    Args:\n        url: The Outorah.org URL to extract from\n\n    Returns:\n        Extraction: Object containing the download URL and title\n\n    Raises:\n        ValueError: If the URL is invalid or content cannot be extracted\n        requests.RequestException: If there are network-related issues\n    \"\"\"\n    try:\n        response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n        response.raise_for_status()\n    except requests.RequestException as e:\n        raise NetworkError(str(e)) from e  # pragma: no cover\n\n    # Parse the page content\n    soup = BeautifulSoup(response.content, \"html.parser\")\n    if download_link := soup.find(\"a\", attrs={\"href\": self.MP3_DOWNLOAD_URL_PATTERN}):\n        download_url = re.search(r\"s3Url=(.*\\.mp3)\", download_link[\"href\"]).group(1)\n        title = re.search(r\"title=(.*?)&amp;\", download_link[\"href\"])\n        if title:\n            title = urllib.parse.unquote(title.group(1))\n    elif download_link := soup.find(\"a\", attrs={\"href\": self.MP4_DOWNLOAD_URL_PATTERN}):\n        download_url = re.search(r\"s3Url=(.*\\.mp4)\", download_link[\"href\"]).group(1)\n        title = re.search(r\"title=(.*?)&amp;\", download_link[\"href\"])\n        if title:\n            title = urllib.parse.unquote(title.group(1))\n    else:\n        raise DownloadURLError()\n\n    file_name = download_url.split(\"/\")[-1]\n\n    if not download_url or not title:\n        raise ContentExtractionError()\n\n    return Extraction(download_url=download_url, title=title, file_format=\"audio/mp3\", file_name=file_name)\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/torahanytime/","title":"torahanytime","text":""},{"location":"reference/torah_dl/core/extractors/torahanytime/#torah_dl.core.extractors.torahanytime.TorahAnytimeExtractor","title":"TorahAnytimeExtractor","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract audio content from TorahAnytime.com.</p> <p>This extractor handles URLs from www.torahanytime.com and extracts MP3 download links along with their associated titles from the page's JavaScript content.</p> Source code in <code>src/torah_dl/core/extractors/torahanytime.py</code> <pre><code>class TorahAnytimeExtractor(Extractor):\n    \"\"\"Extract audio content from TorahAnytime.com.\n\n    This extractor handles URLs from www.torahanytime.com and extracts MP3 download\n    links along with their associated titles from the page's JavaScript content.\n    \"\"\"\n\n    EXAMPLES = [  # noqa: RUF012\n        ExtractionExample(\n            name=\"main_page\",\n            url=\"https://torahanytime.com/lectures/335042\",\n            download_url=\"https://dl.torahanytime.com/mp3/335042--____10_04_2024__ee9743cb-5d09-4ffc-a3e3-1156e10e8944.mp4.mp3\",\n            title=\"Aish Kodesh- Toldot, 5702, When It's Hard to Thank Hashem (2021/22 Series- Enhanced III)\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"short_link\",\n            url=\"https://MyTAT.me/a335042\",\n            download_url=\"https://dl.torahanytime.com/mp3/335042--____10_04_2024__ee9743cb-5d09-4ffc-a3e3-1156e10e8944.mp4.mp3\",\n            title=\"Aish Kodesh- Toldot, 5702, When It's Hard to Thank Hashem (2021/22 Series- Enhanced III)\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"invalid_link\",\n            url=\"https://torahanytime.com/whatever/0000000\",\n            download_url=\"\",\n            title=\"\",\n            file_format=\"\",\n            valid=False,\n        ),\n    ]\n\n    # URL pattern for TorahAnytime.com pages\n    URL_PATTERN = re.compile(r\"https?://(?:www\\.)?torahanytime\\.com/\")\n    # URL pattern for MyTAT.me pages\n    MYTAT_URL_PATTERN = re.compile(r\"https?://(?:www\\.)?MyTAT\\.me/\")\n\n    # Pattern to find download URL in script tags\n    DOWNLOAD_URL_PATTERN = re.compile(r'\"audio_url\\\\?\":\\\\?\"(https.*?)\"')\n\n    @property\n    def url_patterns(self) -&gt; list[Pattern]:\n        \"\"\"Return the URL pattern(s) that this extractor can handle.\n\n        Returns:\n            List[Pattern]: List of compiled regex patterns matching TorahAnytime.com URLs\n        \"\"\"\n        return [self.URL_PATTERN, self.MYTAT_URL_PATTERN]\n\n    def extract(self, url: str) -&gt; Extraction:\n        \"\"\"Extract download URL and title from a TorahAnytime.com page.\n\n        Args:\n            url: The TorahAnytime.com URL to extract from\n\n        Returns:\n            Extraction: Object containing the download URL and title\n\n        Raises:\n            ValueError: If the URL is invalid or content cannot be extracted\n            requests.RequestException: If there are network-related issues\n        \"\"\"\n        try:\n            response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n            response.raise_for_status()\n        except (requests.RequestException, requests.HTTPError) as e:\n            raise NetworkError(str(e)) from e  # pragma: no cover\n\n        # Extract download URL\n        match = self.DOWNLOAD_URL_PATTERN.search(response.text)\n        if not match:\n            raise DownloadURLError()\n\n        download_url = match.group(1).replace(\"\\\\\", \"\")\n\n        file_name = download_url.split(\"/\")[-1]\n\n        # Extract and decode title\n        try:\n            title_match = re.search(r'\\\\\"title\\\\\":\\\\\"(.*?)\\\\\"', response.text)\n            title = title_match.group(1) if title_match else file_name.split(\".\")[0]\n\n        except (UnicodeError, IndexError) as e:\n            raise TitleExtractionError(str(e)) from e\n\n        if not download_url or not title:\n            raise ContentExtractionError()\n\n        return Extraction(download_url=download_url, title=title, file_format=\"audio/mp3\", file_name=file_name)\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/torahanytime/#torah_dl.core.extractors.torahanytime.TorahAnytimeExtractor.url_patterns","title":"url_patterns  <code>property</code>","text":"<pre><code>url_patterns: list[Pattern]\n</code></pre> <p>Return the URL pattern(s) that this extractor can handle.</p> <p>Returns:</p> Type Description <code>list[Pattern]</code> <p>List[Pattern]: List of compiled regex patterns matching TorahAnytime.com URLs</p>"},{"location":"reference/torah_dl/core/extractors/torahanytime/#torah_dl.core.extractors.torahanytime.TorahAnytimeExtractor.extract","title":"extract","text":"<pre><code>extract(url: str) -&gt; Extraction\n</code></pre> <p>Extract download URL and title from a TorahAnytime.com page.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The TorahAnytime.com URL to extract from</p> required <p>Returns:</p> Name Type Description <code>Extraction</code> <code>Extraction</code> <p>Object containing the download URL and title</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL is invalid or content cannot be extracted</p> <code>RequestException</code> <p>If there are network-related issues</p> Source code in <code>src/torah_dl/core/extractors/torahanytime.py</code> <pre><code>def extract(self, url: str) -&gt; Extraction:\n    \"\"\"Extract download URL and title from a TorahAnytime.com page.\n\n    Args:\n        url: The TorahAnytime.com URL to extract from\n\n    Returns:\n        Extraction: Object containing the download URL and title\n\n    Raises:\n        ValueError: If the URL is invalid or content cannot be extracted\n        requests.RequestException: If there are network-related issues\n    \"\"\"\n    try:\n        response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n        response.raise_for_status()\n    except (requests.RequestException, requests.HTTPError) as e:\n        raise NetworkError(str(e)) from e  # pragma: no cover\n\n    # Extract download URL\n    match = self.DOWNLOAD_URL_PATTERN.search(response.text)\n    if not match:\n        raise DownloadURLError()\n\n    download_url = match.group(1).replace(\"\\\\\", \"\")\n\n    file_name = download_url.split(\"/\")[-1]\n\n    # Extract and decode title\n    try:\n        title_match = re.search(r'\\\\\"title\\\\\":\\\\\"(.*?)\\\\\"', response.text)\n        title = title_match.group(1) if title_match else file_name.split(\".\")[0]\n\n    except (UnicodeError, IndexError) as e:\n        raise TitleExtractionError(str(e)) from e\n\n    if not download_url or not title:\n        raise ContentExtractionError()\n\n    return Extraction(download_url=download_url, title=title, file_format=\"audio/mp3\", file_name=file_name)\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/torahapp/","title":"torahapp","text":""},{"location":"reference/torah_dl/core/extractors/torahapp/#torah_dl.core.extractors.torahapp.TorahAppExtractor","title":"TorahAppExtractor","text":"<p>               Bases: <code>Extractor</code></p> Source code in <code>src/torah_dl/core/extractors/torahapp.py</code> <pre><code>class TorahAppExtractor(Extractor):\n    EXAMPLES = [  # noqa: RUF012\n        ExtractionExample(\n            name=\"yu_lecture\",\n            url=\"https://torahapp.org/share/p/YU_80714_all/e/yu:1021736\",\n            download_url=\"https://shiurim.yutorah.net/2022/1109/1021736.MP3\",\n            title=\"Berachos 9:1-2\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"yu_lecture_2\",\n            url=\"https://thetorahapp.org/share/p/YU_80714_all/e/yu:1021737\",\n            download_url=\"https://shiurim.yutorah.net/2022/1109/1021737.MP3\",\n            title=\"Berachos 9:3-4\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"ou_lecture\",\n            url=\"https://thetorahapp.org/share/p/OU_4106?e=http%3A%2F%2Foutorah.org%2Fp%2F81351\",\n            download_url=\"https://media.ou.org/torah/4106/81351/81351.mp3\",\n            title=\"Bo - Chamishi\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"invalid_link\",\n            url=\"https://torahapp.org/share/p/whatever\",\n            download_url=\"\",\n            title=\"\",\n            file_format=\"\",\n            valid=False,\n        ),\n    ]\n\n    PODCAST_ID_PATTERN = re.compile(r\"\\/p\\/([^\\/]+)\")\n    EPISODE_ID_PATTERN = re.compile(r\"\\/e\\/([^\\/]+)\")\n    PODCAST_ID_GET_PATTERN = re.compile(r\"p=([^\\/\\&amp;]+)\")\n    EPISODE_ID_GET_PATTERN = re.compile(r\"e=([^\\/\\&amp;]+)\")\n\n    # dict mapping podcast_id to rss_url\n    podcasts_to_rss = None\n\n    \"\"\"Extract audio content from TorahApp.org.\n\n    This extractor handles URLs from torahapp.org or thetorahapp.org and extracts MP3 download\n    links.\n    \"\"\"\n\n    # URL pattern for torahapp.org pages\n    URL_PATTERN = re.compile(r\"https?://(?:the)?torahapp\\.org\", flags=re.IGNORECASE)\n\n    # Pattern to find download URL in script tags\n    DOWNLOAD_URL_PATTERN = re.compile(r'\"downloadURL\":\"(https?://[^\\\"]+\\.mp3)\"')\n\n    @property\n    def url_patterns(self) -&gt; list[Pattern]:\n        \"\"\"Return the URL pattern(s) that this extractor can handle.\n\n        Returns:\n            List[Pattern]: List of compiled regex patterns matching YUTorah.org URLs\n        \"\"\"\n        return [self.URL_PATTERN]\n\n    def extract(self, url: str) -&gt; Extraction:\n        \"\"\"Extract download URL and title from a YUTorah.org page.\n\n        Args:\n            url: The torahapp.org URL to extract from\n\n        Returns:\n            Extraction: Object containing the download URL and title\n\n        Raises:\n            ValueError: If the URL is invalid or content cannot be extracted\n            requests.RequestException: If there are network-related issues\n        \"\"\"\n        self._get_podcast_metadata()\n        parsed = urlparse(url)\n\n        podcast_id = self._get_value(parsed, self.PODCAST_ID_PATTERN, self.PODCAST_ID_GET_PATTERN)\n        episode_id = self._get_value(parsed, self.EPISODE_ID_PATTERN, self.EPISODE_ID_GET_PATTERN)\n\n        rss = self.podcasts_to_rss[podcast_id]\n        root = self._get_xml_file(rss)\n        result = self._get_download_link(root, episode_id)\n\n        return result\n\n    # get 'e' or 'p' value from parsed url\n    # Example: https://torahapp.org/share/p/YU_80714_all/e/yu:1021736\n    # getting podcast_id=YU_80714_all and episode_id=yu:1021736\n    def _get_value(self, parsed: ParseResult, path_pattern: re.Pattern[str], get_pattern: re.Pattern[str]) -&gt; str:\n        results = set()\n        results.update(re.findall(path_pattern, parsed.path))\n        # unquote() used to convert 'http%3A%2F%2Foutorah.org%2Fp%2F81351' =&gt;\n        # 'http://outorah.org/p/81351'\n        results.update([unquote(x) for x in re.findall(get_pattern, parsed.query)])\n\n        if len(results) &gt; 1:\n            raise MoreThanOneIDFoundError()\n        elif len(results) == 0:\n            raise NoIDFoundError(str(parsed))\n\n        return str(results.pop()).strip()\n\n    def _get_podcast_metadata(self):\n        if self.podcasts_to_rss:\n            return\n\n        response = requests.get(\"https://feeds.thetorahapp.org/data/podcasts_metadata.min.json\", timeout=30)\n        response.raise_for_status()\n        data = response.json()\n\n        self.podcasts_to_rss = {x[\"pId\"]: x[\"u\"] for x in data[\"podcasts\"]}\n\n    def _get_xml_file(self, rss_url: str) -&gt; ET.Element:\n        response = requests.get(str(rss_url), timeout=30)\n        response.raise_for_status()\n        html = response.text.replace(\"&amp;feature=youtu.be&lt;/guid&gt;\", \"&lt;/guid&gt;\")\n        root = DET.fromstring(html)\n        return root\n\n    def _get_download_link(self, root: ET.Element, episode_id: str) -&gt; Extraction:\n        items = root.findall(\"channel/item\")\n        for item in items:\n            guid = item.find(\"guid\").text\n            if guid == episode_id:\n                enclosure = item.find(\"enclosure\")\n                # ex. http://outorah.org/p/81351 =&gt; http:__outorah.org_p_81351\n                file_name = guid.replace(\"/\", \"_\")\n                download_url = enclosure.get(\"url\")\n                episode_title = item.find(\"title\").text\n                # use this to determine if mp3 or whatever file type\n                file_format = enclosure.get(\"type\")\n                if file_format != \"audio/mp3\":\n                    file_format = f\"audio/{download_url.split('.')[-1]}\"\n\n                if not download_url or not episode_title:\n                    raise NoDownloadURLFoundError(episode_id)\n                return Extraction(\n                    download_url=download_url, title=episode_title, file_format=file_format, file_name=file_name\n                )\n        raise GUIDNotFoundError(episode_id)\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/torahapp/#torah_dl.core.extractors.torahapp.TorahAppExtractor.podcasts_to_rss","title":"podcasts_to_rss  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>podcasts_to_rss = None\n</code></pre> <p>Extract audio content from TorahApp.org.</p> <p>This extractor handles URLs from torahapp.org or thetorahapp.org and extracts MP3 download links.</p>"},{"location":"reference/torah_dl/core/extractors/torahapp/#torah_dl.core.extractors.torahapp.TorahAppExtractor.url_patterns","title":"url_patterns  <code>property</code>","text":"<pre><code>url_patterns: list[Pattern]\n</code></pre> <p>Return the URL pattern(s) that this extractor can handle.</p> <p>Returns:</p> Type Description <code>list[Pattern]</code> <p>List[Pattern]: List of compiled regex patterns matching YUTorah.org URLs</p>"},{"location":"reference/torah_dl/core/extractors/torahapp/#torah_dl.core.extractors.torahapp.TorahAppExtractor.extract","title":"extract","text":"<pre><code>extract(url: str) -&gt; Extraction\n</code></pre> <p>Extract download URL and title from a YUTorah.org page.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The torahapp.org URL to extract from</p> required <p>Returns:</p> Name Type Description <code>Extraction</code> <code>Extraction</code> <p>Object containing the download URL and title</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL is invalid or content cannot be extracted</p> <code>RequestException</code> <p>If there are network-related issues</p> Source code in <code>src/torah_dl/core/extractors/torahapp.py</code> <pre><code>def extract(self, url: str) -&gt; Extraction:\n    \"\"\"Extract download URL and title from a YUTorah.org page.\n\n    Args:\n        url: The torahapp.org URL to extract from\n\n    Returns:\n        Extraction: Object containing the download URL and title\n\n    Raises:\n        ValueError: If the URL is invalid or content cannot be extracted\n        requests.RequestException: If there are network-related issues\n    \"\"\"\n    self._get_podcast_metadata()\n    parsed = urlparse(url)\n\n    podcast_id = self._get_value(parsed, self.PODCAST_ID_PATTERN, self.PODCAST_ID_GET_PATTERN)\n    episode_id = self._get_value(parsed, self.EPISODE_ID_PATTERN, self.EPISODE_ID_GET_PATTERN)\n\n    rss = self.podcasts_to_rss[podcast_id]\n    root = self._get_xml_file(rss)\n    result = self._get_download_link(root, episode_id)\n\n    return result\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/torahdownloads/","title":"torahdownloads","text":""},{"location":"reference/torah_dl/core/extractors/torahdownloads/#torah_dl.core.extractors.torahdownloads.TorahDownloadsExtractor","title":"TorahDownloadsExtractor","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract audio content from TorahDownloads.com.</p> <p>This extractor handles URLs from torahdownloads.com and extracts MP3 download links along with their associated titles from various locations in the page.</p> Source code in <code>src/torah_dl/core/extractors/torahdownloads.py</code> <pre><code>class TorahDownloadsExtractor(Extractor):\n    \"\"\"Extract audio content from TorahDownloads.com.\n\n    This extractor handles URLs from torahdownloads.com and extracts MP3 download\n    links along with their associated titles from various locations in the page.\n    \"\"\"\n\n    EXAMPLES = [  # noqa: RUF012\n        ExtractionExample(\n            name=\"main_page\",\n            url=\"https://torahdownloads.com/shiur-23156.html\",\n            download_url=\"https://torahcdn.net/tdn/23156.mp3\",\n            title=\"Acharei Mos  - Maavir Sedra of Pesukim - Rabbi Dovid Grossman - TD23156\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"intro_to_prayer\",\n            url=\"https://torahdownloads.com/shiur-13655.html\",\n            download_url=\"https://torahcdn.net/tdn/13655.mp3\",\n            title=\"Intro To Prayer - Rabbi Mordechai Becher - TD13655\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"invalid_link\",\n            url=\"https://torahdownloads.com/shiur-00000.html\",\n            download_url=\"\",\n            title=\"\",\n            file_format=\"\",\n            valid=False,\n        ),\n    ]\n\n    # URL pattern for TorahDownloads.com pages\n    URL_PATTERN = re.compile(r\"https?://(?:www\\.)?torahdownloads\\.com/\")\n\n    # Pattern to find download URL in script tags\n    SCRIPT_URL_PATTERN = re.compile(r\"(?:audioUrl|audio_url|url)\\s*:\\s*['\\\"]([^'\\\"]+\\.mp3)['\\\"]\", flags=re.IGNORECASE)\n    RAW_URL_PATTERN = re.compile(r\"https?://[^\\\"'\\s]+\\.mp3\")\n\n    @property\n    def url_patterns(self) -&gt; list[Pattern]:\n        \"\"\"Return the URL pattern(s) that this extractor can handle.\n\n        Returns:\n            List[Pattern]: List of compiled regex patterns matching TorahDownloads.com URLs\n        \"\"\"\n        return [self.URL_PATTERN]\n\n    def _extract_title(self, soup: BeautifulSoup) -&gt; str | None:\n        \"\"\"Extract the title from the page using various selectors.\n\n        Args:\n            soup: BeautifulSoup object of the page\n\n        Returns:\n            str | None: The extracted title or None if not found\n        \"\"\"\n        # Try finding the title in the Details section\n        if details := soup.find(\"div\", string=\"Details\"):  # noqa: SIM102\n            if length_text := details.find_next(string=lambda text: text and \"Length:\" in text):  # noqa: SIM102\n                # Get all text nodes between Details and Length\n                if title_node := length_text.find_previous(\n                    string=lambda text: text and text.strip() and \"Details\" not in text\n                ):\n                    return title_node.strip()\n\n        # Try finding the title in the breadcrumb/navigation area\n        if nav_title := soup.find(\"div\", class_=\"nav-title\"):\n            return nav_title.get_text().strip()\n\n        # Try finding any standalone text that looks like a title\n        for text in soup.stripped_strings:\n            text = text.strip()\n            # Skip common non-title text\n            if (\n                text\n                and len(text) &gt; 3\n                and \"Length:\" not in text\n                and \"Details\" not in text\n                and \"Source\" not in text\n                and \"Speaker\" not in text\n                and \"Category\" not in text\n                and \"Language\" not in text\n            ):\n                return text\n\n        return None\n\n    def extract(self, url: str) -&gt; Extraction:\n        \"\"\"Extract download URL and title from a TorahDownloads.com page.\n\n        Args:\n            url: The TorahDownloads.com URL to extract from\n\n        Returns:\n            Extraction: Object containing the download URL and title\n\n        Raises:\n            ValueError: If the URL is invalid or content cannot be extracted\n            requests.RequestException: If there are network-related issues\n        \"\"\"\n        try:\n            response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n            response.raise_for_status()\n        except requests.RequestException as e:\n            raise NetworkError(str(e)) from e  # pragma: no cover\n\n        # Parse the page content\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        html = str(response.content)\n\n        # Extract title first since we'll need it for all cases\n        title = self._extract_title(soup)\n        download_url = None\n\n        # Try finding audio element first\n        media_selector = 'audio source[src*=\".mp3\"], audio[src*=\".mp3\"], a[href*=\".mp3\"]'\n        if audio_element := soup.select_one(media_selector):\n            download_url = audio_element.get(\"src\") or audio_element.get(\"href\")\n\n        # Try finding download link with various patterns\n        if not download_url:\n            download_selector = 'a[href*=\"/download/\"], a[href*=\"getfile\"], a[href*=\"audio\"]'\n            if download_link := soup.select_one(download_selector):\n                download_url = download_link.get(\"href\")\n\n        # Try finding audio URL in script tags\n        if not download_url:\n            for script in soup.find_all(\"script\"):\n                content = script.string or \"\"\n                if media_url_match := self.SCRIPT_URL_PATTERN.search(content):\n                    download_url = media_url_match.group(1)\n                    break\n\n        # Try finding in the raw HTML for any mp3 URLs\n        if not download_url and (media_url_match := self.RAW_URL_PATTERN.search(html)):\n            download_url = media_url_match.group(0)\n\n        if download_url:\n            file_name = download_url.split(\"/\")[-1]\n            return Extraction(download_url=download_url, title=title, file_format=\"audio/mp3\", file_name=file_name)\n\n        raise DownloadURLError()\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/torahdownloads/#torah_dl.core.extractors.torahdownloads.TorahDownloadsExtractor.url_patterns","title":"url_patterns  <code>property</code>","text":"<pre><code>url_patterns: list[Pattern]\n</code></pre> <p>Return the URL pattern(s) that this extractor can handle.</p> <p>Returns:</p> Type Description <code>list[Pattern]</code> <p>List[Pattern]: List of compiled regex patterns matching TorahDownloads.com URLs</p>"},{"location":"reference/torah_dl/core/extractors/torahdownloads/#torah_dl.core.extractors.torahdownloads.TorahDownloadsExtractor.extract","title":"extract","text":"<pre><code>extract(url: str) -&gt; Extraction\n</code></pre> <p>Extract download URL and title from a TorahDownloads.com page.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The TorahDownloads.com URL to extract from</p> required <p>Returns:</p> Name Type Description <code>Extraction</code> <code>Extraction</code> <p>Object containing the download URL and title</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL is invalid or content cannot be extracted</p> <code>RequestException</code> <p>If there are network-related issues</p> Source code in <code>src/torah_dl/core/extractors/torahdownloads.py</code> <pre><code>def extract(self, url: str) -&gt; Extraction:\n    \"\"\"Extract download URL and title from a TorahDownloads.com page.\n\n    Args:\n        url: The TorahDownloads.com URL to extract from\n\n    Returns:\n        Extraction: Object containing the download URL and title\n\n    Raises:\n        ValueError: If the URL is invalid or content cannot be extracted\n        requests.RequestException: If there are network-related issues\n    \"\"\"\n    try:\n        response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n        response.raise_for_status()\n    except requests.RequestException as e:\n        raise NetworkError(str(e)) from e  # pragma: no cover\n\n    # Parse the page content\n    soup = BeautifulSoup(response.content, \"html.parser\")\n    html = str(response.content)\n\n    # Extract title first since we'll need it for all cases\n    title = self._extract_title(soup)\n    download_url = None\n\n    # Try finding audio element first\n    media_selector = 'audio source[src*=\".mp3\"], audio[src*=\".mp3\"], a[href*=\".mp3\"]'\n    if audio_element := soup.select_one(media_selector):\n        download_url = audio_element.get(\"src\") or audio_element.get(\"href\")\n\n    # Try finding download link with various patterns\n    if not download_url:\n        download_selector = 'a[href*=\"/download/\"], a[href*=\"getfile\"], a[href*=\"audio\"]'\n        if download_link := soup.select_one(download_selector):\n            download_url = download_link.get(\"href\")\n\n    # Try finding audio URL in script tags\n    if not download_url:\n        for script in soup.find_all(\"script\"):\n            content = script.string or \"\"\n            if media_url_match := self.SCRIPT_URL_PATTERN.search(content):\n                download_url = media_url_match.group(1)\n                break\n\n    # Try finding in the raw HTML for any mp3 URLs\n    if not download_url and (media_url_match := self.RAW_URL_PATTERN.search(html)):\n        download_url = media_url_match.group(0)\n\n    if download_url:\n        file_name = download_url.split(\"/\")[-1]\n        return Extraction(download_url=download_url, title=title, file_format=\"audio/mp3\", file_name=file_name)\n\n    raise DownloadURLError()\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/yutorah/","title":"yutorah","text":""},{"location":"reference/torah_dl/core/extractors/yutorah/#torah_dl.core.extractors.yutorah.YutorahExtractor","title":"YutorahExtractor","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract audio content from YUTorah.org.</p> <p>This extractor handles URLs from www.yutorah.org and extracts MP3 download links along with their associated titles from the page's JavaScript content.</p> Source code in <code>src/torah_dl/core/extractors/yutorah.py</code> <pre><code>class YutorahExtractor(Extractor):\n    \"\"\"Extract audio content from YUTorah.org.\n\n    This extractor handles URLs from www.yutorah.org and extracts MP3 download\n    links along with their associated titles from the page's JavaScript content.\n    \"\"\"\n\n    EXAMPLES = [  # noqa: RUF012\n        ExtractionExample(\n            name=\"main_page\",\n            url=\"https://www.yutorah.org/lectures/1116616/Praying-for-Rain-and-the-International-Traveler\",\n            download_url=\"https://download.yutorah.org/2024/986/1116616/praying-for-rain-and-the-international-traveler.mp3\",\n            title=\"Praying for Rain and the International Traveler\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"short_link\",\n            url=\"https://www.yutorah.org/lectures/1117459/\",\n            download_url=\"https://download.yutorah.org/2024/986/1117459/davening-with-strep-throat.mp3\",\n            title=\"Davening with Strep Throat\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"shiurid_link\",\n            url=\"https://www.yutorah.org/lectures/details?shiurid=1117409\",\n            download_url=\"https://download.yutorah.org/2024/21197/1117409/ketubot-42-dechitat-aveilut-1.mp3\",\n            title=\"Ketubot 42: Dechitat Aveilut (1)\",\n            file_format=\"audio/mp3\",\n            valid=True,\n        ),\n        ExtractionExample(\n            name=\"invalid_link\",\n            url=\"https://www.yutorah.org/lectures/details?shiurid=0000000\",\n            download_url=\"\",\n            title=\"\",\n            file_format=\"\",\n            valid=False,\n        ),\n    ]\n\n    # URL pattern for YUTorah.org pages\n    URL_PATTERN = re.compile(r\"https?://(?:www\\.)?yutorah\\.org/\")\n\n    # Pattern to find download URL in script tags\n    DOWNLOAD_URL_PATTERN = re.compile(r'\"downloadURL\":\"(https?://[^\\\"]+\\.mp3)\"')\n\n    @property\n    def url_patterns(self) -&gt; list[Pattern]:\n        \"\"\"Return the URL pattern(s) that this extractor can handle.\n\n        Returns:\n            List[Pattern]: List of compiled regex patterns matching YUTorah.org URLs\n        \"\"\"\n        return [self.URL_PATTERN]\n\n    def extract(self, url: str) -&gt; Extraction:\n        \"\"\"Extract download URL and title from a YUTorah.org page.\n\n        Args:\n            url: The YUTorah.org URL to extract from\n\n        Returns:\n            Extraction: Object containing the download URL and title\n\n        Raises:\n            ValueError: If the URL is invalid or content cannot be extracted\n            requests.RequestException: If there are network-related issues\n        \"\"\"\n        try:\n            response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n            response.raise_for_status()\n        except requests.RequestException as e:\n            raise NetworkError(str(e)) from e  # pragma: no cover\n\n        # Parse the page content\n        soup = BeautifulSoup(response.content, \"html.parser\")\n        script_tag = soup.find(\"script\", string=self.DOWNLOAD_URL_PATTERN)\n\n        if not script_tag:\n            raise DownloadURLError()\n\n        # Extract download URL\n        match = self.DOWNLOAD_URL_PATTERN.search(str(script_tag))\n        if not match:\n            raise DownloadURLError()\n\n        download_url = match.group(1)\n\n        file_name = download_url.split(\"/\")[-1]\n\n        # Extract and decode title\n        try:\n            title_tag = soup.find(\"h2\", itemprop=\"name\")\n            title = title_tag.text if title_tag else None\n\n        except (UnicodeError, IndexError) as e:\n            raise TitleExtractionError(str(e)) from e\n\n        if not download_url or not title:\n            raise ContentExtractionError()\n\n        return Extraction(download_url=download_url, title=title, file_format=\"audio/mp3\", file_name=file_name)\n</code></pre>"},{"location":"reference/torah_dl/core/extractors/yutorah/#torah_dl.core.extractors.yutorah.YutorahExtractor.url_patterns","title":"url_patterns  <code>property</code>","text":"<pre><code>url_patterns: list[Pattern]\n</code></pre> <p>Return the URL pattern(s) that this extractor can handle.</p> <p>Returns:</p> Type Description <code>list[Pattern]</code> <p>List[Pattern]: List of compiled regex patterns matching YUTorah.org URLs</p>"},{"location":"reference/torah_dl/core/extractors/yutorah/#torah_dl.core.extractors.yutorah.YutorahExtractor.extract","title":"extract","text":"<pre><code>extract(url: str) -&gt; Extraction\n</code></pre> <p>Extract download URL and title from a YUTorah.org page.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The YUTorah.org URL to extract from</p> required <p>Returns:</p> Name Type Description <code>Extraction</code> <code>Extraction</code> <p>Object containing the download URL and title</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the URL is invalid or content cannot be extracted</p> <code>RequestException</code> <p>If there are network-related issues</p> Source code in <code>src/torah_dl/core/extractors/yutorah.py</code> <pre><code>def extract(self, url: str) -&gt; Extraction:\n    \"\"\"Extract download URL and title from a YUTorah.org page.\n\n    Args:\n        url: The YUTorah.org URL to extract from\n\n    Returns:\n        Extraction: Object containing the download URL and title\n\n    Raises:\n        ValueError: If the URL is invalid or content cannot be extracted\n        requests.RequestException: If there are network-related issues\n    \"\"\"\n    try:\n        response = requests.get(url, timeout=30, headers={\"User-Agent\": \"torah-dl/1.0\"})\n        response.raise_for_status()\n    except requests.RequestException as e:\n        raise NetworkError(str(e)) from e  # pragma: no cover\n\n    # Parse the page content\n    soup = BeautifulSoup(response.content, \"html.parser\")\n    script_tag = soup.find(\"script\", string=self.DOWNLOAD_URL_PATTERN)\n\n    if not script_tag:\n        raise DownloadURLError()\n\n    # Extract download URL\n    match = self.DOWNLOAD_URL_PATTERN.search(str(script_tag))\n    if not match:\n        raise DownloadURLError()\n\n    download_url = match.group(1)\n\n    file_name = download_url.split(\"/\")[-1]\n\n    # Extract and decode title\n    try:\n        title_tag = soup.find(\"h2\", itemprop=\"name\")\n        title = title_tag.text if title_tag else None\n\n    except (UnicodeError, IndexError) as e:\n        raise TitleExtractionError(str(e)) from e\n\n    if not download_url or not title:\n        raise ContentExtractionError()\n\n    return Extraction(download_url=download_url, title=title, file_format=\"audio/mp3\", file_name=file_name)\n</code></pre>"}]}